---
title: Javascript之内存空间
date: 2018-04-19 22:26:03
tags: JavaScript
---

# 堆与栈

我们都知道：在计算机领域中，堆栈是两种数据结构，它们只能在一端(称为栈顶(top))对数据项进行插入和删除。

堆：队列优先,先进先出；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
栈：先进后出；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 

# 栈内存（变量对象）与基本数据类型

JavaScript中的数据类型大致分为，基本数据类型与引用数据类型
1. 基本类型：Undefined、Null、Boolean、Number 和 String，这5中基本数据类型可以直接访问，他们是按照值进行分配的，存放在栈(stack)内存中的简单数据段，数据大小确定，内存空间大小可以分配。 
2. 引用类型：即存放在堆(heap)内存中的对象，变量实际保存的是一个指针，这个指针指向另一个位置。 
```js
var a  = 20;
var b  = a;
b = 30;
console.log(a);//20
```
上面这段代码指的是，在变量对象中执行数据复制的时候，其实系统会自动为新的变量在栈中分配一个新的值，所以a与b其实已经是完全独立的两个变量，只是值一样而已。
![示意图](https://upload-images.jianshu.io/upload_images/2244949-e955796f01e5de80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 堆内存与引用数据类型

javascript中的引用数据类型是存放在堆内存中的，但是不同于变量对象，javascript是不允许直接访问堆内存中的数据，所以如果我们要访问引用数据类型的时候，采用的是按引用访问，其实就是在变量对象中存放了一个指向对象的句柄，可以理解为一个地址，要访问堆内存中的对象，就要通过这个引用句柄来访问，例如上图中的d变量，就是一个指向对象的地址。
```js
demo02
var m = { a:10,b:20};
var n = m;  // 也就是我们熟知的浅拷贝
n.a = 15;
console.log(m.a);//15
```
上面这段代码指的是执行引用类型数据的复制时，在变量对象中会分配一个新的值，来存放新的变量，但是这两个变量的地址是一样的，相当于指向的对象是一样的，所以各自改变对象里面的属性值，会互相影响，如下图
![示意图](https://upload-images.jianshu.io/upload_images/2244949-af0cd54131f3ca4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 内存泄漏

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。

对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

## 内存生命周期

不管什么程序语言，内存生命周期基本是一致的：   

1. 分配你所需要的内存
2. 使用分配到的内存（读、写）
3. 不需要时将其释放\归还

在所有语言中第一和第二部分都很清晰。最后一步在底层语言中很清晰，但是在像JavaScript 等上层语言中，这一步是隐藏的。

## 垃圾回收机制

垃圾回收机制怎么知道，哪些内存不再需要呢？

最常使用的方法叫做["引用计数"](https://en.wikipedia.org/wiki/Reference_counting)（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放。

![引用表](https://upload-images.jianshu.io/upload_images/2244949-78b0bb956eee747a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图中，左下角的两个值，没有任何引用，所以可以释放。

如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。

```js
const arr = [1, 2, 3, 4];
console.log('hello world');
```
上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。

如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。

```js
let arr = [1, 2, 3, 4];
console.log('hello world');
arr = null;
```
上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。

在局部作用域中，等函数执行完毕，变量就没有存在的必要了，js垃圾回收机制很快做出判断并且回收，但是对于全局变量，很难判断什么时候不用，所以，经验之谈就是，尽量少使用全局变量。

我们在使用闭包的时候，就会造成严重的内存泄漏，因为闭包的原因，局部变量会一直保存在内存中，所以在使用闭包的时候，要多加小心。